\Chapter{Design}

\Section{Interpreters and their operation}
[General overview of interpreters and basic principles]
[Short description of parts and pros against compilers]

\Section{Implementation requirements}
[Due to past research the need arose for such an interpreter in MATLAB/Octave]

\Section{Lexical Analyzer}
[Data structures and functional dependency between modules of the tokenizer]
[Valid token list, (keywords, strings, numbers, terminals?, etc.)]
[Considerations, preparation of text]
[Method of analyzing and correctly checking each token]
[Room for possible future extensions (string escapes, terminals and special symbols, dominates and other keywords)]

\Section{Parser}
[Overview of each grammar rule]
[Specific implementation to parse the given grammar with recursive descent parsing technique]
[Building the syntax tree and considerations for the data structures being used]
[Additional semantical checks after parsing]
[Room for possible future extensions: warnings for missing elements, parsing optional arguments, rule domination hierarchy, extension of the existing grammar?, parsing techniques required in case of certain grammar modification, eg.: precedence climbing for evaluation of mathematical expressions instead of  using constants]

\Section{Engine}
[Calculation of fuzzy rule interpolation and inference of resultant values]
[Operations based on the mathematical fuzzy automaton]
[Behavior control and further reusing output values]

\Section{Error handling}
[Built in Octave error handling, but a generic one should be used]
[To avoid code entanglement and logically difficult to understand fault checking]
[Reporting and error messages for helping find the apparent problem within the input code]